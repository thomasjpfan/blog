<!DOCTYPE html><html lang="en"><head><title>Hassle Free UNets</title><meta charset="utf-8"><meta name="author" content="Thomas J. Fan"><meta name="viewport" content="width=device-width,minimum-scale=1,maximum-scale=1"><link rel="apple-touch-icon" href="https://thomasjpfan.github.io/favicon_v4.png"><meta property="og:image" content="https://thomasjpfan.github.io/favicon_v4.png"><meta property="og:type" content="article"><meta property="og:locale" content="en_US"><meta name="twitter:card" content="summary"><meta name="twitter:site" content="@thomasjpfan"><meta name="twitter:creator" content="@thomasjpfan"><meta name="twitter:image" content="https://thomasjpfan.github.io/favicon_v4.png"><meta name="description" property="og:description" content="<p>Constructing a UNet requires you to keep track of every signal size that flow through the UNet. This can lead to size mismatches when constructing the neutral network. To remedy this issue, I created a small PyTorch UNet module that calculates the sizes for you. You can even customize the building blocks used to construct the UNet.</p>"><meta name="description" content="<p>Constructing a UNet requires you to keep track of every signal size that flow through the UNet. This can lead to size mismatches when constructing the neutral network. To remedy this issue, I created a small PyTorch UNet module that calculates the sizes for you. You can even customize the building blocks used to construct the UNet.</p>"><meta name="og:title" property="og:title" content="Hassle Free UNets"><meta name="og:url" property="og:url" content="https://thomasjpfan.github.io/2017/08/hassle-free-unets/"><meta name="twitter:title" content="Hassle Free UNets"><meta name="twitter:description" content="<p>Constructing a UNet requires you to keep track of every signal size that flow through the UNet. This can lead to size mismatches when constructing the neutral network. To remedy this issue, I created a small PyTorch UNet module that calculates the sizes for you. You can even customize the building blocks used to construct the UNet.</p>"><link rel="shortcut icon" href="https://thomasjpfan.github.io/favicon_v5.ico"><link rel="stylesheet" href="https://thomasjpfan.github.io/theme/css/style0c1abd42.css"><meta name="generator" content="Pelican"><link href="https://thomasjpfan.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="thomasjpfan.github.io Full Atom Feed"><link href="https://thomasjpfan.github.io/feeds/blog.atom.xml" type="application/atom+xml" rel="alternate" title="thomasjpfan.github.io Categories Atom Feed"></head><body><header><div class="header-wrapper"><div class="header-inner-wrapper"><div class="header-brand"><a href="/">tf<span>.</span></a></div><nav><div class="nav-search"><form action="https://thomasjpfan.github.io/search.html" onsubmit="return validateForm(this.elements['q'].value);"><label for="tipue_search_input" class="visuallyhidden">Search</label><input type="text" class="nav-search--input search-query" placeholder="Search" name="q" id="tipue_search_input"></form></div><div class="nav-links"><div class="nav-link"><a href="https://github.com/thomasjpfan" target="_blank" rel="noopener"><i class="fa fa-github"></i> github</a></div><div class="nav-link"><a href="https://twitter.com/thomasjpfan" target="_blank" rel="noopener"><i class="fa fa-twitter"></i> twitter</a></div><div class="nav-link"><a href="/pages/about/"><i class="fa fa-user"></i> about</a></div><div class="nav-link"><a href="/pages/talks/"><i class="fa fa-flask"></i> talks</a></div></div></nav></div></div></header> <main><article class="content"><div class="article content-wrapper"><h1 class="article-title"><a href rel="bookmark" title="Permalink to Hassle Free UNets"> Hassle Free UNets </a></h1><div class="article-header"><a class="article-header-link" title="2017-08-05T09:29:00-05:00" href="/2017/08/hassle-free-unets/">August 05, 2017</a><div class="article-header-tags-wrapper"><a class="tag article-header-tag" href="/topic/deep-learning/">deep learning</a></div></div> <div class="entry-content"><p>Constructing a <code>UNet</code> requires you to keep track of every signal size that flow through the UNet. This can lead to size mismatches when constructing the neutral network. To remedy this issue, I created a small PyTorch UNet module that calculates the sizes for you. You can even customize the building blocks used to construct the <code>UNet</code>. The UNet module can be found on <a href="https://github.com/thomasjpfan/pytorch_unet">github</a></p><h2>Introduction</h2><p>The UNet architecture, introduced in this <a href="link">paper</a>, has the following structure:</p><p><img alt="UNet Architecture" src="/images/20170805_Hassle_Free_Unets/unet_arch.png" title="UNet Architecture"></p><p>The primary use for a <code>UNet</code> is to perform segmentation. In the above case, the UNet is used to detect cancerous regions in the input image. There are four blocks to constructing a <code>UNet</code>: split, center, merge, and final blocks. My implementation of UNet has the following initialization method:</p><div class="highlight"><pre><span class="code-line"><span></span><code><span class="k">class</span> <span class="nc">UNet</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">input_shape</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">num_classes</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">layers</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">features_root</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">split_block</span><span class="o">=</span><span class="n">SplitBlock</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">merge_block</span><span class="o">=</span><span class="n">MergeBlock</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">center_block</span><span class="o">=</span><span class="n">CenterBlock</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">final_block</span><span class="o">=</span><span class="n">FinalBlock</span><span class="p">,</span></span>
<span class="code-line">                 <span class="n">double_center_features</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span></span>
<span class="code-line">                 <span class="o">...</span></span>
<span class="code-line"></code></pre></div><p>You can alter any of the four blocks used to generate the <code>UNet</code>. The <code>layers</code> parameter determines how tall the UNet is. For example, the image above has four layers. Each split layer upscales the signal to <code>2**layer*features_root</code> where <code>layer</code> is the zero-indexed layer number.</p><p>I will use the short hand, <code>(features, size)</code>, in my diagrams to denote the shape <code>features x size x size</code> of my signals. For example, <code>(112, 32)</code>, means the signal has the shape <code>112x32x32</code>.</p><h2>Split Block</h2><p>The split block has two outputs and one input:</p><p><img alt="Split Block" src="/images/20170805_Hassle_Free_Unets/split_block.png" title="Split Block"></p><p>The shapes of the outputs are calculated for you, all you have to do is provide your custom implementation of the split block. For reference, here is the default <code>split_block</code> implementation:</p><div class="highlight"><pre><span class="code-line"><span></span><code><span class="k">class</span> <span class="nc">SplitBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_shape</span><span class="p">,</span> <span class="n">up_shape</span><span class="p">,</span> <span class="n">hor_shape</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span></span>
<span class="code-line">        <span class="o">...</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span></span>
<span class="code-line">        <span class="o">...</span></span>
<span class="code-line">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_pool</span><span class="p">(</span><span class="n">hor</span><span class="p">),</span> <span class="n">hor</span></span>
<span class="code-line"></code></pre></div><p>The extra <code>layer</code> index is passed in, just in case you want to adjust the block for different layers. To create your custom implementation, just copy the <code>SplitBlock</code> implementation and change the bodies of <code>__init__</code> and <code>forward</code>. Make sure that the <code>forward</code> call returns two values, the first being the <code>up</code> signal and second being the <code>hor</code> signal. The parameters <code>{}_shape</code> uses the convention <code>(features, size)</code>. You can use these parameters to perform assertions on the signal shapes during initialization.</p><h2>Center Block</h2><p>The center block has one input and one output:</p><p><img alt="Center Block" src="/images/20170805_Hassle_Free_Unets/center_block.png" title="Center Block"></p><p>This block does not change the size of the signal, only the number of features change. Thus the default <code>center_block</code> implementation just needs the feature number:</p><div class="highlight"><pre><span class="code-line"><span></span><code><span class="k">class</span> <span class="nc">CenterBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_feats</span><span class="p">,</span> <span class="n">out_feats</span><span class="p">):</span></span>
<span class="code-line">        <span class="o">...</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span></span>
<span class="code-line">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></span>
<span class="code-line"></code></pre></div><p>If <code>double_center_features</code> from <code>UNet</code> initialization is <code>True</code>, <code>out_feats</code> is two times <code>in_feats</code>, otherwise they are the same.</p><h2>Merge Block</h2><p>The merge block has two inputs and one output:</p><p><img alt="Merge Block" src="/images/20170805_Hassle_Free_Unets/merge_block.png" title="Merge Block"></p><p>The default implementation of this block is:</p><div class="highlight"><pre><span class="code-line"><span></span><code><span class="k">class</span> <span class="nc">MergeBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span></span>
<span class="code-line">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_shape</span><span class="p">,</span> <span class="n">out_shape</span><span class="p">,</span> <span class="n">hor_shape</span><span class="p">,</span> <span class="n">layer</span><span class="p">):</span></span>
<span class="code-line">        <span class="o">...</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">hor</span><span class="p">):</span></span>
<span class="code-line">        <span class="k">return</span> <span class="n">out</span></span>
<span class="code-line"></code></pre></div><p>The <code>in_shape</code> and <code>out_shape</code> parameters depends on the <code>double_center_features</code>. If the features were doubled at the center block, the features going down the merge block will also be doubled. <code>forward</code> takes in two inputs and outputs one signal.</p><h2>Final Block</h2><p>The final block has one input and one output:</p><p><img alt="Final Block" src="/images/20170805_Hassle_Free_Unets/final_block.png" title="Final Block"></p><p>The default final block just has a single convolution layer:</p><div class="highlight"><pre><span class="code-line"><span></span><code><span class="k">class</span> <span class="nc">FinalBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_feats</span><span class="p">,</span> <span class="n">out_feats</span><span class="p">):</span></span>
<span class="code-line">        <span class="bp">self</span><span class="o">.</span><span class="n">layer</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span><span class="n">in_feats</span><span class="p">,</span> <span class="n">out_feats</span><span class="p">,</span> <span class="n">kernel_size</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span></span>
<span class="code-line"></span>
<span class="code-line">    <span class="k">def</span> <span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span></span>
<span class="code-line">        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">layer</span><span class="p">(</span><span class="n">x</span><span class="p">)</span></span>
<span class="code-line"></code></pre></div><p>The final block outputs a signal of size <code>(num_classes, input_size)</code>, which which was passed into <code>UNet</code> initialization. Each pixel is given a logit value for each class. This can transform to a probability by using a sigmoid layer.</p><h2>Conclusion</h2><p>This <code>UNet</code> module allowed me to quickly experiment with different blocks and hyper-parameters for any segmentation problem. Hopefully you it can help you too! :D</p></div><div class="article-subtitle"><section class="subtitle"><div class="share-items-wrapper"><h3>Share this post</h3><div class="share-items"><div class="share-item"><a href="https://twitter.com/intent/tweet?original_referer=https://thomasjpfan.github.io/2017/08/hassle-free-unets/&text=Hassle Free UNets&url=https://thomasjpfan.github.io/2017/08/hassle-free-unets/&via=thomasjpfan" title="Tweet this !" target="_blank" rel="noopener"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></div><div class="share-item"><a href="http://www.facebook.com/share.php?u=https://thomasjpfan.github.io/2017/08/hassle-free-unets/" title="Share this on Facebook" target="_blank" rel="noopener"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-facebook fa-stack-1x fa-inverse"></i></span></a></div><div class="share-item"><a href="mailto:?subject=Hassle Free UNets&body=https://thomasjpfan.github.io/2017/08/hassle-free-unets/" title="Email this" class="email" target="_blank" rel="noopener"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-envelope fa-stack-1x fa-inverse"></i></span></a></div></div></div><section class="similar-posts"><h3>Similar Posts</h3><dl class="dl-tags"><dt>07/31/18</dt><dd><a href="/2018/07/nuclei-image-segmentation-tutorial/">Nuclei Image Segmentation Tutorial</a></dd></dl></section></section></div></div></article></main><footer><div class="footer-wrapper"><div class="footer-inner-wrapper"><div class="footer-profile"><div class="footer-brand"><a href="/"><span>thomasjpfan.github.io</span></a></div><div class="footer-about"><p>Thomas J. Fan's personal blog where I share my thoughts and insights.</p></div></div><div class="footer-contact"><span>Contact</span><div class="footer-contact-message"><p>Have any feedback or questions? Just send me a tweet or an email!</p></div><div class="footer-social-items"><ul><li class="footer-social-item"><a href="https://twitter.com/thomasjpfan" title="Tweet me" target="_blank" rel="noopener"><span class="fa-stack fa-lg"><i class="fa fa-circle fa-stack-2x"></i><i class="fa fa-twitter fa-stack-1x fa-inverse"></i></span></a></li><li class="footer-social-item"><script>
              var username = "thomasjpfan";
              var hostname = "gmail.com";
              var linktext = username + "@" + hostname ;
              document.write("<a href=\"" + "mailto:" + username + "@" + hostname + "\" title=\"Email me\"target=\"_blank\"><span class=\"fa-stack fa-lg\"><i class=\"fa fa-circle fa-stack-2x\"></i><i class=\"fa fa-envelope fa-stack-1x fa-inverse\"></i></span></a>");
              </script></li></ul></div></div><div class="footer-site-detail"><span>Site</span><ul class="footer-links"><li class="footer-link"><a href="/"><i class="fa fa-th-list"></i> front page</a></li><li class="footer-link"><a href="/archives/"><i class="fa fa-archive"></i> archives</a></li><li class="footer-link"><a href="/topics"><i class="fa fa-tags"></i> topics</a></li><li class="footer-link"><a href="None"><i class="fa fa-rss"></i> rss</a></li></ul></div></div></div></footer> <script>
		function validateForm(query) {
			return (query.length > 0);
		}
	</script><script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://thomasjpfan.github.io/theme/js/tipuesearch.min.js"></script><script>

		var renderJqueryDeps = function ($) {
		};

		var loadAll = function () {
			renderJqueryDeps(jQuery);
		};

		// var raf = requestAnimationFrame || mozRequestAnimationFrame || webkitRequestAnimationFrame || msRequestAnimationFrame;
		// if (raf) raf(function() { window.setTimeout(loadAll, 0); });
		// else
		// window.addEventListener('load', loadAll);
		(function () {
			var onReady = function onReady(fn) {
			  if (document.addEventListener) {
				document.addEventListener("DOMContentLoaded", fn);
			  } else {
				document.attachEvent("onreadystatechange", function () {
				  if (document.readyState === "interactive") {
					fn();
				  }
				});
			  }
			};

			onReady(function () {
				loadAll();
			});
		  })();
	</script></body></html>